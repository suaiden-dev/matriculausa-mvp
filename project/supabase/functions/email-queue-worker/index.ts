// üóÉÔ∏è EMAIL QUEUE WORKER - Processa emails sequencialmente
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY') || Deno.env.get('VITE_GEMINI_API_KEY');

// üîí SISTEMA DE LOCK PARA EVITAR EXECU√á√ïES SIMULT√ÇNEAS
const LOCK_KEY = 'email_worker_lock';
const LOCK_TIMEOUT = 60000; // 1 minuto timeout para lock (reduzido para evitar locks longos)

async function acquireLock(): Promise<boolean> {
  try {
    console.log('üîí [LOCK] Tentando adquirir lock...');
    
    // Verificar se j√° existe lock ativo
    const { data: existingLock } = await supabase
      .from('worker_locks')
      .select('*')
      .eq('lock_key', LOCK_KEY)
      .eq('is_active', true)
      .maybeSingle();
    
    if (existingLock) {
      const lockAge = Date.now() - new Date(existingLock.created_at).getTime();
      console.log(`üîí [LOCK] Lock existente encontrado - idade: ${lockAge}ms, timeout: ${LOCK_TIMEOUT}ms`);
      if (lockAge < LOCK_TIMEOUT) {
        console.log('üîí [LOCK] Lock j√° existe e √© v√°lido - abortando execu√ß√£o');
        return false;
      } else {
        console.log('üîí [LOCK] Lock expirado - removendo e criando novo');
        await supabase
          .from('worker_locks')
          .delete()
          .eq('lock_key', LOCK_KEY);
      }
    }
    
    // Criar novo lock
    const { error } = await supabase
      .from('worker_locks')
      .insert({
        lock_key: LOCK_KEY,
        is_active: true,
        created_at: new Date().toISOString()
      });
    
    if (error) {
      console.error('üîí [LOCK] Erro ao criar lock:', error);
      return false;
    }
    
    console.log('üîí [LOCK] Lock adquirido com sucesso');
    return true;
  } catch (error) {
    console.error('üîí [LOCK] Erro ao adquirir lock:', error);
    return false;
  }
}

async function releaseLock(): Promise<void> {
  try {
    console.log('üîí [LOCK] Liberando lock...');
    await supabase
      .from('worker_locks')
      .delete()
      .eq('lock_key', LOCK_KEY);
    console.log('üîí [LOCK] Lock liberado com sucesso');
  } catch (error) {
    console.error('üîí [LOCK] Erro ao liberar lock:', error);
  }
}

async function cleanupExpiredLocks(): Promise<void> {
  try {
    console.log('üßπ [CLEANUP] Limpando locks expirados...');
    const { error } = await supabase
      .from('worker_locks')
      .delete()
      .lt('created_at', new Date(Date.now() - LOCK_TIMEOUT).toISOString());
    
    if (error) {
      console.error('üßπ [CLEANUP] Erro ao limpar locks:', error);
    } else {
      console.log('üßπ [CLEANUP] Locks expirados removidos');
    }
  } catch (error) {
    console.error('üßπ [CLEANUP] Erro na limpeza:', error);
  }
}

// üõ°Ô∏è CONFIGURA√á√ïES ULTRA CONSERVADORAS PARA FILA
const QUEUE_CONFIG = {
  batchSize: 1, // Processar 1 email por vez
  delayBetweenEmails: 30000, // 30 segundos entre emails (respeitando quota Gemini)
  maxRetries: 3,
  retryDelay: 60000, // 1 minuto para retry
  maxEmailsPerRun: 2, // M√°ximo 2 emails por execu√ß√£o (quota Gemini: 4/min)
  timeoutPerEmail: 30000, // 30 segundos timeout por email
  geminiRateLimit: 15000, // 15 segundos entre chamadas Gemini (4/min = 15s)
};

// ü§ñ Classe AIService simplificada para o worker
class QueueAIService {
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async processEmail(email: any, userId: string): Promise<any> {
    try {
      console.log(`ü§ñ [WORKER] Processando email: ${email.subject}`);
      
      // Buscar informa√ß√µes completas do agente
      const { data: agentData } = await supabase
        .from('ai_configurations')
        .select('id, ai_name, company_name, personality, final_prompt')
        .eq('user_id', userId)
        .eq('is_active', true)
        .maybeSingle();
        
      // üîç BUSCAR BASE DE CONHECIMENTO ESPEC√çFICA DO AGENTE
      let knowledgeBase = '';
      try {
        // Primeiro, buscar documentos espec√≠ficos do agente
        const { data: agentDocs, error: agentDocsError } = await supabase
          .from('ai_agent_knowledge_documents')
          .select('transcription, document_name')
          .eq('ai_configuration_id', agentData?.id || '')
          .eq('transcription_status', 'completed')
          .not('transcription', 'is', null);
        
        if (!agentDocsError && agentDocs && agentDocs.length > 0) {
          knowledgeBase = agentDocs
            .map(doc => `## ${doc.document_name}\n\n${doc.transcription}`)
            .join('\n\n---\n\n');
          console.log(`üìö [WORKER] Documentos espec√≠ficos do agente encontrados: ${agentDocs.length} documentos`);
        } else {
          console.log(`üìö [WORKER] Nenhum documento espec√≠fico do agente encontrado`);
        }
      } catch (error) {
        console.error('‚ùå [WORKER] Erro ao buscar base de conhecimento do agente:', error);
      }
        
      // Criar prompt personalizado automaticamente
      let universityPrompt;
      if (agentData) {
        const { ai_name, company_name, personality, final_prompt } = agentData;
        universityPrompt = final_prompt || `You are ${ai_name}, an AI assistant for ${company_name}. 
        
PERSONALITY: ${personality}
UNIVERSITY: ${company_name}
AGENT NAME: ${ai_name}

Always use your real name (${ai_name}) and the university name (${company_name}) in your responses.`;
      } else {
        universityPrompt = 'You are a university assistant.';
      }
      
      // üîó INTEGRAR BASE DE CONHECIMENTO NO PROMPT
      if (knowledgeBase) {
        universityPrompt += `\n\n<knowledge-base>\n${knowledgeBase}\n</knowledge-base>\n\nIMPORTANTE: Use as informa√ß√µes da base de conhecimento acima para responder √†s perguntas dos estudantes. Se a informa√ß√£o n√£o estiver na base de conhecimento, responda de forma geral e sugira que o estudante entre em contato diretamente com a universidade para informa√ß√µes espec√≠ficas.`;
      }
      
      // Preparar prompt para Gemini
      const emailContent = `
Assunto: ${email.subject}
De: ${email.from?.emailAddress?.address || 'Unknown'}
Conte√∫do: ${email.bodyPreview || email.body?.content || 'Sem conte√∫do'}
`;

      // Detectar idioma do email
      const emailText = `${email.subject} ${email.bodyPreview || email.body?.content || ''}`.toLowerCase();
      const isEnglish = /\b(hello|hi|dear|sir|madam|thank|please|help|information|about|study|university|scholarship|application|admission|process|requirements|documents|payment|fee|cost|price|when|where|how|what|why|can|could|would|should|need|want|interested|apply|enroll|register|contact|email|phone|address|website|program|course|degree|bachelor|master|phd|undergraduate|graduate|international|student|usa|america|united states)\b/.test(emailText);
      
      const languageInstruction = isEnglish 
        ? "Respond in English. Be professional and helpful."
        : "Responda em portugu√™s. Seja profissional e prestativo.";

      const fullPrompt = `${universityPrompt}

Analise o seguinte email e determine se deve ser respondido:
${emailContent}

IMPORTANTE: 
- ${languageInstruction}
- Use a base de conhecimento fornecida para dar respostas espec√≠ficas e √∫teis
- Seja espec√≠fico sobre programas, bolsas e processos da universidade
- Forne√ßa informa√ß√µes detalhadas sobre MatriculaUSA, bolsas e programas

Responda APENAS com um JSON v√°lido no formato:
{
  "shouldReply": boolean,
  "priority": "high" | "medium" | "low",
  "category": "application" | "scholarship" | "documents" | "payment" | "admission" | "general",
  "confidence": number (0-1),
  "response": "sua resposta aqui" | null,
  "reason": "motivo da decis√£o"
}`;

      // Fazer requisi√ß√£o para Gemini
      console.log(`üîë [WORKER] Usando Gemini API Key: ${this.apiKey ? 'CONFIGURADA' : 'N√ÉO CONFIGURADA'}`);
      console.log(`üì° [WORKER] Fazendo requisi√ß√£o para Gemini...`);
      
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: fullPrompt }] }]
        })
      });

      console.log(`üìä [WORKER] Gemini Response Status: ${response.status}`);
      console.log(`ü§ñ [WORKER] ===== CHAMANDO IA GEMINI =====`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå [WORKER] Gemini API Error ${response.status}:`, errorText);
        
        if (response.status === 401) {
          console.error(`üö® [WORKER] GEMINI 401 UNAUTHORIZED - API KEY INV√ÅLIDA!`);
        }
        
        if (response.status === 429) {
          console.error(`üö® [WORKER] GEMINI 429 QUOTA EXCEEDED - Aguardando 180s...`);
          await new Promise(resolve => setTimeout(resolve, 180000)); // 180 segundos (3 minutos)
        }
        
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const geminiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      console.log(`ü§ñ [WORKER] ===== RESPOSTA DA IA =====`);
      console.log(`üìù [WORKER] Resposta completa: ${geminiResponse}`);
      console.log(`ü§ñ [WORKER] ========================`);
      
      if (!geminiResponse) {
        throw new Error('Resposta vazia do Gemini');
      }

      // Parse do JSON com fallbacks
      let result;
      try {
        const cleanJson = geminiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        result = JSON.parse(cleanJson);
      } catch (parseError) {
        console.log(`‚ö†Ô∏è [WORKER] Erro no JSON, usando an√°lise simples para: ${email.subject}`);
        result = {
          shouldReply: true,
          priority: 'medium',
          category: 'general',
          confidence: 0.5,
          response: `Obrigado pelo seu email. Entraremos em contato em breve.`,
          reason: 'An√°lise simples devido a erro de parsing'
        };
      }

        console.log(`‚úÖ [WORKER] Email analisado: shouldReply=${result.shouldReply}, category=${result.category}`);
        console.log(`ü§ñ [WORKER] ===== RESULTADO FINAL DA IA =====`);
        console.log(`üéØ [WORKER] Deve responder: ${result.shouldReply}`);
        console.log(`üìù [WORKER] Categoria: ${result.category}`);
        console.log(`üí¨ [WORKER] Resposta gerada: ${result.response ? result.response.substring(0, 150) + '...' : 'NENHUMA'}`);
        console.log(`ü§ñ [WORKER] ================================`);
      return { analysis: result, response: result.response };
      
    } catch (error) {
      console.error(`‚ùå [WORKER] Erro ao processar email:`, error);
      return {
        analysis: {
          shouldReply: false,
          priority: 'low',
          category: 'error',
          confidence: 0,
          reason: `Erro: ${error.message}`
        },
        response: null
      };
    }
  }

  // üõ°Ô∏è C√°lculo de delay humanizado (vers√£o conservadora)
  calculateHumanDelay(analysis: any): number {
    const { category, priority } = analysis;
    
    // Base delay em segundos (ultra conservador)
    let baseDelay = 30; // 30 segundos base
    
    switch (category) {
      case 'payment':
        baseDelay = 25; // Mais r√°pido para pagamentos
        break;
      case 'application':
      case 'scholarship':
        baseDelay = 35; // Mais lento para aplica√ß√µes
        break;
      case 'documents':
        baseDelay = 30;
        break;
      case 'general':
        baseDelay = 28;
        break;
      default:
        baseDelay = 30;
    }
    
    // Ajustar por prioridade
    if (priority === 'high') {
      baseDelay *= 0.8;
    } else if (priority === 'low') {
      baseDelay *= 1.3;
    }
    
    // Randomiza√ß√£o humana (¬±15%)
    const variation = (Math.random() - 0.5) * 0.3;
    baseDelay = baseDelay * (1 + variation);
    
    // Garantir limites seguros
    return Math.max(20, Math.min(45, Math.round(baseDelay)));
  }
}

// üöÄ Fun√ß√£o principal do worker
async function processEmailQueue(): Promise<void> {
  console.log('üóÉÔ∏è [WORKER] Iniciando processamento da fila de emails');
  
  if (!GEMINI_API_KEY) {
    console.error('‚ùå [WORKER] GEMINI_API_KEY n√£o configurada');
    return;
  }
  
  const aiService = new QueueAIService(GEMINI_API_KEY);
  let processedCount = 0;
  
  try {
    // üõ°Ô∏è PROTE√á√ÉO ANTI-DUPLICA√á√ÉO: Buscar emails pendentes com verifica√ß√£o de duplica√ß√£o
    const { data: queueItems, error: fetchError } = await supabase
      .from('email_queue')
      .select('*')
      .eq('status', 'pending')
      .order('priority', { ascending: true })
      .order('created_at', { ascending: true })
      .limit(QUEUE_CONFIG.maxEmailsPerRun);
      
    // üö® VERIFICA√á√ÉO CR√çTICA: Filtrar emails j√° processados
    const processedEmails = new Set();
    const uniqueQueueItems = [];
    
    // üîç VERIFICA√á√ÉO NO BANCO: Buscar emails j√° processados com SUCESSO na tabela processed_microsoft_emails
    const { data: alreadyProcessed, error: processedError } = await supabase
      .from('processed_microsoft_emails')
      .select('microsoft_message_id, status')
      .in('microsoft_message_id', queueItems?.map(item => item.email_data?.id).filter(Boolean) || [])
      .in('status', ['processed', 'replied']); // APENAS emails processados com sucesso
    
    if (processedError) {
      console.error('‚ùå [WORKER] Erro ao verificar emails processados:', processedError);
    } else {
      console.log(`üîç [WORKER] Emails j√° processados com SUCESSO no banco: ${alreadyProcessed?.length || 0}`);
    }
    
    const processedMessageIds = new Set(alreadyProcessed?.map(p => p.microsoft_message_id) || []);
    
    for (const item of queueItems || []) {
      const emailId = item.email_data?.id;
      
      // Verificar duplicata na fila
      if (emailId && !processedEmails.has(emailId)) {
        processedEmails.add(emailId);
        
        // Verificar se j√° foi processado com SUCESSO no banco
        if (processedMessageIds.has(emailId)) {
          console.log(`üö´ [WORKER] EMAIL J√Å PROCESSADO COM SUCESSO NO BANCO - Pulando email: ${emailId}`);
          // Marcar como j√° processado
          await supabase
            .from('email_queue')
            .update({ 
              status: 'completed',
              error_message: 'Email j√° processado anteriormente com sucesso',
              completed_at: new Date().toISOString()
            })
            .eq('id', item.id);
          continue;
        }
        
        // üîÑ REPROCESSAR EMAILS COM ERRO: Limpar registros de erro para permitir reprocessamento
        const { data: errorEmails } = await supabase
          .from('processed_microsoft_emails')
          .select('id')
          .eq('microsoft_message_id', emailId)
          .eq('status', 'error');
          
        if (errorEmails && errorEmails.length > 0) {
          console.log(`üîÑ [WORKER] REPROCESSANDO EMAIL COM ERRO: ${emailId}`);
          // Deletar registros de erro para permitir reprocessamento
          await supabase
            .from('processed_microsoft_emails')
            .delete()
            .eq('microsoft_message_id', emailId)
            .eq('status', 'error');
        }
        
        uniqueQueueItems.push(item);
      } else if (emailId) {
        console.log(`üö´ [WORKER] DUPLICATA DETECTADA - Pulando email: ${emailId}`);
        // Marcar como duplicata
        await supabase
          .from('email_queue')
          .update({ 
            status: 'failed',
            error_message: 'Email duplicado - j√° processado',
            completed_at: new Date().toISOString()
          })
          .eq('id', item.id);
      }
    }
      
    if (fetchError) {
      console.error('‚ùå [WORKER] Erro ao buscar fila:', fetchError);
      return;
    }
    
    if (!uniqueQueueItems || uniqueQueueItems.length === 0) {
      console.log('‚úÖ [WORKER] Fila vazia - nenhum email √∫nico para processar');
      return;
    }
    
    console.log(`üìß [WORKER] Encontrados ${queueItems?.length || 0} emails na fila`);
    console.log(`üõ°Ô∏è [WORKER] Ap√≥s filtro anti-duplica√ß√£o: ${uniqueQueueItems.length} emails √∫nicos`);
    
    // Processar cada email sequencialmente
    for (const queueItem of uniqueQueueItems) {
      try {
        console.log(`\nüîÑ [WORKER] Processando email ${queueItem.id} (${queueItem.email_data.subject})`);
        
        // Marcar como processando
        await supabase
          .from('email_queue')
          .update({
            status: 'processing',
            started_at: new Date().toISOString()
          })
          .eq('id', queueItem.id);
        
        // Processar email com timeout
        const emailPromise = aiService.processEmail(queueItem.email_data, queueItem.user_id);
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), QUEUE_CONFIG.timeoutPerEmail)
        );
        
        const result = await Promise.race([emailPromise, timeoutPromise]) as any;
        
        // Determinar se deve enviar resposta
        let finalStatus = 'completed';
        if (result.analysis.shouldReply && result.response) {
          // Calcular delay humanizado
          const delaySeconds = aiService.calculateHumanDelay(result.analysis);
          console.log(`‚è∞ [WORKER] Aguardando ${delaySeconds}s antes de enviar resposta...`);
          
          // Aplicar delay humanizado
          await new Promise(resolve => setTimeout(resolve, delaySeconds * 1000));
          
          // üìß ENVIAR RESPOSTA REAL via Microsoft Graph
          try {
            // Buscar configura√ß√£o do usu√°rio para obter access token
            const { data: userConfig } = await supabase
              .from('email_configurations')
              .select('oauth_access_token, oauth_refresh_token, oauth_token_expires_at, email_address')
              .eq('user_id', queueItem.user_id)
              .eq('provider_type', 'microsoft')
              .eq('is_active', true)
              .single();
            
            let accessToken = userConfig?.oauth_access_token;
            
            // Verificar se token est√° v√°lido
            if (userConfig && userConfig.oauth_token_expires_at) {
              const expiresAt = new Date(userConfig.oauth_token_expires_at);
              const now = new Date();
              const isExpired = expiresAt <= now;
              
              if (isExpired) {
                console.log(`‚ö†Ô∏è [WORKER] Token expirado, n√£o √© poss√≠vel renovar automaticamente no worker`);
                console.log(`üìß [WORKER] Email ser√° marcado como falha - usu√°rio precisa renovar token`);
                accessToken = null;
              } else {
                console.log(`‚úÖ [WORKER] Token v√°lido at√©: ${expiresAt.toISOString()}`);
              }
            }
            
            if (accessToken) {
              // üìß Enviar resposta via Microsoft Graph API diretamente
              console.log(`üîë [WORKER] Usando Microsoft Token: ${accessToken ? 'CONFIGURADO' : 'N√ÉO CONFIGURADO'}`);
              console.log(`üì° [WORKER] Fazendo requisi√ß√£o para Microsoft Graph...`);
              
              const replyResponse = await fetch(`https://graph.microsoft.com/v1.0/me/messages/${queueItem.email_data.id}/reply`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${accessToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  message: {
                    body: {
                      contentType: 'Text',
                      content: result.response
                    }
                  }
                })
              });
              
              console.log(`üìä [WORKER] Microsoft Graph Response Status: ${replyResponse.status}`);
              
              if (replyResponse.ok) {
                console.log(`‚úâÔ∏è [WORKER] Resposta REAL enviada para: ${queueItem.email_data.subject}`);
                console.log(`üìù [WORKER] Resposta: ${result.response.substring(0, 100)}...`);
              } else {
                const errorData = await replyResponse.text();
                console.error(`‚ùå [WORKER] Erro ao enviar via Graph API (${replyResponse.status}):`, errorData);
                
                if (replyResponse.status === 401) {
                  console.error(`üö® [WORKER] MICROSOFT GRAPH 401 UNAUTHORIZED - TOKEN INV√ÅLIDO!`);
                }
                
                console.log(`üìù [WORKER] Resposta (n√£o enviada): ${result.response.substring(0, 100)}...`);
              }
            } else {
              console.log(`‚ö†Ô∏è [WORKER] Token n√£o dispon√≠vel, simulando envio para: ${queueItem.email_data.subject}`);
              console.log(`üìù [WORKER] Resposta: ${result.response.substring(0, 100)}...`);
            }
          } catch (sendError) {
            console.error(`‚ùå [WORKER] Erro ao enviar resposta real:`, sendError);
            console.log(`üìù [WORKER] Resposta (n√£o enviada): ${result.response.substring(0, 100)}...`);
          }
          
          finalStatus = 'completed';
        } else {
          console.log(`üö´ [WORKER] Email n√£o requer resposta: ${result.analysis.reason}`);
          finalStatus = 'completed';
        }
        
        // Marcar como conclu√≠do
        await supabase
          .from('email_queue')
          .update({
            status: finalStatus,
            completed_at: new Date().toISOString()
          })
          .eq('id', queueItem.id);
          
        // ‚úÖ APENAS SALVAR NA TABELA AP√ìS PROCESSAMENTO COMPLETO COM SUCESSO
        console.log(`üíæ [WORKER] Salvando email processado na tabela processed_microsoft_emails...`);
        const { data: upsertData, error: upsertError } = await supabase.from('processed_microsoft_emails').upsert({
          microsoft_message_id: queueItem.email_data.id,
          user_id: queueItem.user_id,
          connection_email: 'queue@system.com',
          subject: queueItem.email_data.subject,
          from_email: queueItem.email_data.from?.emailAddress?.address,
          status: result.analysis.shouldReply ? 'replied' : 'processed',
          analysis: result.analysis,
          response_text: result.response,
          processed_at: new Date().toISOString()
        }, {
          onConflict: 'microsoft_message_id,user_id,connection_email'
        });
        
        if (upsertError) {
          console.error(`‚ùå [WORKER] Erro ao salvar email processado:`, upsertError);
        } else {
          console.log(`‚úÖ [WORKER] Email processado salvo/atualizado com sucesso na tabela`);
        }
        
        processedCount++;
        console.log(`‚úÖ [WORKER] Email ${queueItem.id} processado com sucesso`);
        
        // Delay m√≠nimo entre emails (prote√ß√£o anti-spam + quota Gemini)
        if (processedCount < queueItems.length) {
          const delay = Math.max(QUEUE_CONFIG.delayBetweenEmails, QUEUE_CONFIG.geminiRateLimit);
          console.log(`‚è≥ [WORKER] Aguardando ${delay/1000}s antes do pr√≥ximo email (respeitando quota Gemini)...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
      } catch (error) {
        console.error(`‚ùå [WORKER] Erro ao processar email ${queueItem.id}:`, error);
        
        // Marcar como falha e preparar retry
        const retryCount = (queueItem.retry_count || 0) + 1;
        const shouldRetry = retryCount <= QUEUE_CONFIG.maxRetries;
        
        await supabase
          .from('email_queue')
          .update({
            status: shouldRetry ? 'failed' : 'failed',
            completed_at: shouldRetry ? null : new Date().toISOString(),
            error_message: error.message,
            retry_count: retryCount,
            next_retry_at: shouldRetry ? new Date(Date.now() + QUEUE_CONFIG.retryDelay).toISOString() : null
          })
          .eq('id', queueItem.id);
      }
    }
    
    console.log(`\nüéâ [WORKER] Processamento conclu√≠do: ${processedCount} emails processados`);
    
  } catch (error) {
    console.error('üí• [WORKER] Erro cr√≠tico no processamento da fila:', error);
  }
}

// üöÄ Handler da Edge Function
Deno.serve(async (req) => {
  console.log('üóÉÔ∏è [WORKER] Email Queue Worker iniciado');
  console.log('üîç [WORKER] Method:', req.method);
  console.log('üîç [WORKER] URL:', req.url);
  console.log('üîç [WORKER] Headers:', Object.fromEntries(req.headers.entries()));
  console.log('üîç [WORKER] Timestamp:', new Date().toISOString());
  
  // üßπ LIMPAR LOCKS EXPIRADOS PRIMEIRO
  await cleanupExpiredLocks();
  
  // üîí ADQUIRIR LOCK ANTES DE PROCESSAR
  const lockAcquired = await acquireLock();
  if (!lockAcquired) {
    console.log('üö´ [WORKER] Lock n√£o adquirido - abortando execu√ß√£o');
    return new Response(JSON.stringify({ 
      success: false, 
      message: 'Worker j√° est√° em execu√ß√£o' 
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  // CORS Headers
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
    'Access-Control-Max-Age': '86400',
  };
  
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    console.log('‚úÖ [WORKER] CORS preflight request handled');
    return new Response(null, { status: 200, headers: corsHeaders });
  }
  
  try {
    if (req.method === 'POST') {
      const body = await req.json();
      
      // Chatbot mode
      if (body.chatbotMode) {
        console.log('üí¨ [WORKER] Modo chatbot ativado');
        
        try {
          // Verificar limite de uso
          const sessionId = body.sessionId || `session_${body.userId}_${Date.now()}`;
          console.log(`üîç [WORKER] Verificando limite para universidade ${body.userId}, sess√£o ${sessionId}`);
          
          const { data: usageCheck, error: usageError } = await supabase
            .rpc('check_ai_usage_limit', {
              p_university_id: body.userId,
              p_session_id: sessionId
            });
            
          if (usageError) {
            console.error('‚ùå [WORKER] Erro ao verificar limite:', usageError);
            return new Response(JSON.stringify({ 
              error: 'Failed to check usage limit',
              success: false 
            }), { 
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
          
          console.log('üìä [WORKER] Status do uso:', usageCheck);
          
          if (!usageCheck.can_use) {
            console.log('üö´ [WORKER] Limite de prompts atingido');
            return new Response(JSON.stringify({ 
              error: 'Daily prompt limit reached',
              message: `You have reached the limit of ${usageCheck.max_prompts} prompts per session. Please try again tomorrow.`,
              success: false,
              usage: usageCheck
            }), { 
              status: 429,
              headers: { 'Content-Type': 'application/json' }
            });
          }
          
          // Incrementar contador de uso
          const { data: usageUpdate, error: incrementError } = await supabase
            .rpc('increment_ai_usage', {
              p_university_id: body.userId,
              p_session_id: sessionId
            });
            
          if (incrementError) {
            console.error('‚ùå [WORKER] Erro ao incrementar uso:', incrementError);
          } else {
            console.log('‚úÖ [WORKER] Uso incrementado:', usageUpdate);
          }
          
          // Buscar prompt da universidade
          const { data: agentData } = await supabase
            .from('ai_configurations')
            .select('id, ai_name, company_name, personality, final_prompt')
            .eq('user_id', body.userId)
            .eq('is_active', true)
            .maybeSingle();
            
          // üîç BUSCAR BASE DE CONHECIMENTO ESPEC√çFICA DO AGENTE
          let knowledgeBase = '';
          try {
            // Primeiro, buscar documentos espec√≠ficos do agente
            const { data: agentDocs, error: agentDocsError } = await supabase
              .from('ai_agent_knowledge_documents')
              .select('transcription, document_name')
              .eq('ai_configuration_id', agentData?.id || '')
              .eq('transcription_status', 'completed')
              .not('transcription', 'is', null);
            
            if (!agentDocsError && agentDocs && agentDocs.length > 0) {
              knowledgeBase = agentDocs
                .map(doc => `## ${doc.document_name}\n\n${doc.transcription}`)
                .join('\n\n---\n\n');
              console.log(`üìö [WORKER] Documentos espec√≠ficos do agente encontrados: ${agentDocs.length} documentos`);
            } else {
              console.log(`üìö [WORKER] Nenhum documento espec√≠fico do agente encontrado`);
            }
          } catch (error) {
            console.error('‚ùå [WORKER] Erro ao buscar base de conhecimento do agente:', error);
          }
            
          // Criar prompt personalizado automaticamente
          let universityPrompt;
          if (agentData) {
            const { ai_name, company_name, personality, final_prompt } = agentData;
            universityPrompt = final_prompt || `You are ${ai_name}, an AI assistant for ${company_name}. 
            
PERSONALITY: ${personality}
UNIVERSITY: ${company_name}
AGENT NAME: ${ai_name}

Always use your real name (${ai_name}) and the university name (${company_name}) in your responses.`;
          } else {
            universityPrompt = 'You are a university assistant.';
          }
          
          // üîó INTEGRAR BASE DE CONHECIMENTO NO PROMPT
          if (knowledgeBase) {
            universityPrompt += `\n\n<knowledge-base>\n${knowledgeBase}\n</knowledge-base>\n\nIMPORTANTE: Use as informa√ß√µes da base de conhecimento acima para responder √†s perguntas dos estudantes. Se a informa√ß√£o n√£o estiver na base de conhecimento, responda de forma geral e sugira que o estudante entre em contato diretamente com a universidade para informa√ß√µes espec√≠ficas.`;
          }
          
          // Detectar idioma da mensagem
          const messageText = body.message?.toLowerCase() || '';
          
          // Detectar idiomas espec√≠ficos
          const isEnglish = /\b(hello|hi|dear|thank|please|help|information|about|study|university|scholarship|application|admission|process|requirements|documents|payment|fee|cost|price|when|where|how|what|why|can|could|would|should|need|want|interested|apply|enroll|register|contact|email|phone|address|website|program|course|degree|bachelor|master|phd|undergraduate|graduate|international|student|usa|america|united states|want|do|this|hello|how|are|you)\b/.test(messageText);
          
          const isSpanish = /\b(hola|buenos|d√≠as|tarde|noche|gracias|por|favor|ayuda|informaci√≥n|sobre|estudiar|universidad|beca|solicitud|admis√≥n|proceso|requisitos|documentos|pago|cuota|costo|precio|cu√°ndo|d√≥nde|c√≥mo|qu√©|por|qu√©|puedo|podr√≠a|deber√≠a|necesito|quiero|interesado|aplicar|matricular|registrar|contacto|correo|tel√©fono|direcci√≥n|sitio|programa|curso|grado|licenciatura|maestr√≠a|doctorado|pregrado|posgrado|internacional|estudiante|estados|unidos|america|quiero|hacer|esto|hola|c√≥mo|est√°|solicitar|beca|universidad)\b/.test(messageText);
          
          const isJapanese = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(messageText) || 
                            /\b(„Åì„Çì„Å´„Å°„ÅØ|„ÅØ„Åò„ÇÅ„Åæ„Åó„Å¶|„ÅÇ„Çä„Åå„Å®„ÅÜ|„ÅäÈ°ò„ÅÑ|Âä©„Åë„Å¶|ÊÉÖÂ†±|„Å´„Å§„ÅÑ„Å¶|ÂãâÂº∑|Â§ßÂ≠¶|Â•®Â≠¶Èáë|Áî≥Ë´ã|ÂÖ•Â≠¶|„Éó„É≠„Çª„Çπ|Ë¶Å‰ª∂|Êõ∏È°û|ÊîØÊâï„ÅÑ|ÊñôÈáë|Ë≤ªÁî®|‰æ°Ê†º|„ÅÑ„Å§|„Å©„Åì|„Å©„ÅÆ„Çà„ÅÜ„Å´|‰Ωï|„Å™„Åú|„Åß„Åç„Åæ„Åô|„Åß„Åç„Çã|„Åô„Åπ„Åç|ÂøÖË¶Å|„Åó„Åü„ÅÑ|ËààÂë≥|ÂøúÂãü|ÁôªÈå≤|ÈÄ£Áµ°|„É°„Éº„É´|ÈõªË©±|‰ΩèÊâÄ|„Ç¶„Çß„Éñ„Çµ„Ç§„Éà|„Éó„É≠„Ç∞„É©„É†|„Ç≥„Éº„Çπ|Â≠¶‰Ωç|Â≠¶Â£´|‰øÆÂ£´|ÂçöÂ£´|Â≠¶ÈÉ®|Â§ßÂ≠¶Èô¢|ÂõΩÈöõ|Â≠¶Áîü|„Ç¢„É°„É™„Ç´|ÂêàË°ÜÂõΩ|„Åó„Åü„ÅÑ|„Åì„Çå|„Åì„Çì„Å´„Å°„ÅØ|„ÅÑ„Åã„Åå|Â•®Â≠¶Èáë|Áî≥Ë´ã|Â§ßÂ≠¶)\b/.test(messageText);
          
          const isFrench = /\b(bonjour|bonsoir|merci|s'il|vous|pla√Æt|aide|information|sur|√©tudier|universit√©|bourse|demande|admission|processus|exigences|documents|paiement|frais|co√ªt|prix|quand|o√π|comment|quoi|pourquoi|peux|peut|devrais|besoin|veux|int√©ress√©|postuler|s'inscrire|enregistrer|contact|email|t√©l√©phone|adresse|site|programme|cours|dipl√¥me|licence|ma√Ætrise|doctorat|premier|cycle|deuxi√®me|cycle|international|√©tudiant|√©tats|unis|am√©rique|veux|faire|ceci|bonjour|comment|allez|demander|bourse|universit√©)\b/.test(messageText);
          
          const isGerman = /\b(hallo|guten|tag|abend|danke|bitte|hilfe|information|√ºber|studieren|universit√§t|stipendium|bewerbung|zulassung|prozess|anforderungen|dokumente|zahlung|geb√ºhr|kosten|preis|wann|wo|wie|was|warum|kann|k√∂nnte|sollte|brauche|will|interessiert|bewerben|einschreiben|registrieren|kontakt|email|telefon|adresse|website|programm|kurs|abschluss|bachelor|master|doktor|grundstudium|aufbaustudium|international|student|usa|amerika|will|tun|dies|hallo|wie|geht|stipendium|beantragen|universit√§t)\b/.test(messageText);
          
          // Determinar idioma de resposta
          let languageInstruction;
          if (isEnglish) {
            languageInstruction = "Respond in English. Be professional and helpful.";
          } else if (isSpanish) {
            languageInstruction = "Responde en espa√±ol. S√© profesional y servicial.";
          } else if (isJapanese) {
            languageInstruction = "Êó•Êú¨Ë™û„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´„ÅßË¶™Âàá„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
          } else if (isFrench) {
            languageInstruction = "R√©pondez en fran√ßais. Soyez professionnel et serviable.";
          } else if (isGerman) {
            languageInstruction = "Antworten Sie auf Deutsch. Seien Sie professionell und hilfsbereit.";
          } else {
            languageInstruction = "Responda em portugu√™s. Seja profissional e prestativo.";
          }

          const chatPrompt = `${universityPrompt}

Mensagem do usu√°rio: ${body.message}

IMPORTANTE: 
- ${languageInstruction}
- Use a base de conhecimento fornecida para dar respostas espec√≠ficas e √∫teis
- Seja espec√≠fico sobre programas, bolsas e processos da universidade
- Forne√ßa informa√ß√µes detalhadas sobre MatriculaUSA, bolsas e programas
- Se n√£o souber algo espec√≠fico, seja honesto mas ofere√ßa alternativas

Responda de forma natural e conversacional, como um assistente universit√°rio.`;

          // Fazer requisi√ß√£o para Gemini
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: chatPrompt }] }]
            })
          });

          if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
          }

          const data = await response.json();
          const geminiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;
          
          return new Response(JSON.stringify({
            success: true,
            response: geminiResponse || 'Sorry, I could not process your message.',
            analysis: { chatbotMode: true },
            usage: usageUpdate
          }), {
            status: 200,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          });
        } catch (error) {
          console.error('‚ùå [WORKER] Erro no modo chatbot:', error);
          return new Response(JSON.stringify({
            success: false,
            response: 'Desculpe, ocorreu um erro ao processar sua mensagem.',
            error: error.message
          }), {
            status: 500,
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          });
        }
      }
      
      if (body.trigger === 'process_queue') {
        console.log('üéØ [WORKER] Trigger recebido - processando fila');
        await processEmailQueue();
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Fila processada com sucesso'
        }), {
          status: 200,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        });
      }
    }
    
    // Processamento autom√°tico se n√£o for um trigger espec√≠fico
    await processEmailQueue();
    
    return new Response(JSON.stringify({
      success: true,
      message: 'Worker executado com sucesso'
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('‚ùå [WORKER] Erro no handler:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  } finally {
    // üîí LIBERAR LOCK SEMPRE (mesmo em caso de erro)
    await releaseLock();
  }
});
